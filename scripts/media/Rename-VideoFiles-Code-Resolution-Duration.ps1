<#
.SYNOPSIS
    Renames video files to include codec and resolution information with consistent formatting.

.DESCRIPTION
    This script renames video files in the specified directory by:
    1. Replacing spaces, dashes, and underscores with periods
    2. Adding the video codec information (x264, x265, etc.)
    3. Adding the resolution information (2160p, 1080p, 720p, 480p, etc.)
    4. Adding the dimensions (WxH) and aspect ratio
    5. Adding the duration in minutes (XXXmin format)
    
    The final format will be: OriginalName.x264.1080p.1920x1080.16.9.XXmin.extension

.PARAMETER TargetDirectory
    The directory containing video files to process. If not specified, the current directory is used.

.PARAMETER MediaInfoPath
    The path to the MediaInfo executable. By default, it tries to find MediaInfo in common installation locations.

.EXAMPLE
    .\Rename-VideoFiles.ps1 -TargetDirectory "C:\Users\Username\Videos"
    
    Renames all video files in the specified directory.

.EXAMPLE
    .\Rename-VideoFiles.ps1
    
    Renames all video files in the current directory.

.NOTES
    Requires MediaInfo to be installed on the system to detect video codec and resolution.
    Author: Generated by AI Assistant
    Date: 2025-05-12
#>

[CmdletBinding()]
param (
    [Parameter(Position = 0)]
    [string]$TargetDirectory = (Get-Location).Path,
    
    [Parameter()]
    [string]$MediaInfoPath = ""
)

function Find-MediaInfo {
    # First check the WinGet/AppData location (CLI version)
    $wingetPath = "C:\Users\$env:USERNAME\AppData\Local\Microsoft\WinGet\Packages\MediaArea.MediaInfo_Microsoft.Winget.Source_8wekyb3d8bbwe\MediaInfo.exe"
    if (Test-Path $wingetPath) {
        return $wingetPath
    }
    
    # Then check if MediaInfo is in PATH
    $mediaInfoInPath = Get-Command "mediainfo" -ErrorAction SilentlyContinue
    if ($mediaInfoInPath) {
        return $mediaInfoInPath.Source
    }
    
    # Finally check Program Files locations (often GUI version)
    $programFilesPaths = @(
        "C:\Program Files\MediaInfo\MediaInfo.exe",
        "C:\Program Files (x86)\MediaInfo\MediaInfo.exe"
    )
    
    foreach ($path in $programFilesPaths) {
        if (Test-Path $path) {
            return $path
        }
    }
    
    return $null
}

function Test-VideoFile {
    param (
        [Parameter(Mandatory = $true)]
        [System.IO.FileInfo]$File
    )
    
    $videoExtensions = @(".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".webm", ".m4v", ".mpg", ".mpeg", ".ts")
    return $videoExtensions -contains $File.Extension.ToLower()
}

# Main script execution starts here
try {
    # Validate target directory
    if (-not (Test-Path -Path $TargetDirectory -PathType Container)) {
        throw "Target directory does not exist: $TargetDirectory"
    }
    
    # Find MediaInfo if not specified
    if ([string]::IsNullOrEmpty($MediaInfoPath)) {
        $MediaInfoPath = Find-MediaInfo
        if ($null -eq $MediaInfoPath) {
            throw "MediaInfo not found. Please install MediaInfo or specify the path with -MediaInfoPath."
        }
    }
    elseif (-not (Test-Path -Path $MediaInfoPath -PathType Leaf)) {
        throw "The specified MediaInfo path does not exist: $MediaInfoPath"
    }
    
    Write-Host "Using MediaInfo from: $MediaInfoPath" -ForegroundColor Cyan
    Write-Host "Processing files in: $TargetDirectory" -ForegroundColor Cyan
    
    # Get all files in the target directory
    $files = Get-ChildItem -Path $TargetDirectory -File | Where-Object { Test-VideoFile -File $_ }
    
    if ($files.Count -eq 0) {
        Write-Host "No video files found in the target directory." -ForegroundColor Yellow
        return
    }
    
    Write-Host "Found $($files.Count) video files to process." -ForegroundColor Green
    
    # Process each file
    foreach ($file in $files) {
        Write-Host "`nProcessing: $($file.Name)" -ForegroundColor Cyan
        
        # Get video codec and height
        # Get video codec, height, and duration
        $codec = & $MediaInfoPath --Inform="Video;%Format%" $file.FullName
        $height = [int](& $MediaInfoPath --Inform="Video;%Height%" $file.FullName)
        $width = [int](& $MediaInfoPath --Inform="Video;%Width%" $file.FullName)
        $durationInMs = [double](& $MediaInfoPath --Inform="General;%Duration%" $file.FullName)
        if ([string]::IsNullOrEmpty($codec) -or $height -eq 0) {
            Write-Host "  Could not detect codec or resolution for '$($file.Name)'. Skipping..." -ForegroundColor Yellow
            continue
        }
        
        Write-Host "  Detected codec: $codec" -ForegroundColor Gray
        Write-Host "  Detected dimensions: ${width}x${height}" -ForegroundColor Gray
        
        # Calculate actual aspect ratio using GCD for simplification
        $gcd = {
            param([int]$a, [int]$b)
            if ($b -eq 0) { return $a }
            return & $gcd $b ($a % $b)
        }
        
        # Use GCD to find the simplified ratio
        $aspectRatioGcd = & $gcd $width $height
        $aspectRatioWidth = $width / $aspectRatioGcd
        $aspectRatioHeight = $height / $aspectRatioGcd
        
        # Format with colon for readability
        $aspectRatio = "$aspectRatioWidth.$aspectRatioHeight"
        
        # Also calculate decimal ratio for reference
        $rawAspectRatio = $width / $height
        Write-Host "  Aspect ratio: $aspectRatio (decimal: $([math]::Round($rawAspectRatio, 2)))" -ForegroundColor Gray
        
        # Convert milliseconds to minutes 
        $durationInMinutes = [math]::Round($durationInMs / 60000)
        
        # Fix for very short videos - anything with a non-zero duration less than 1 minute gets "1min"
        if ($durationInMs -gt 0 -and $durationInMinutes -lt 1) {
            # Ensure any video with a duration shows at least 1min
            $durationInMinutes = 1
            Write-Host "  Short video detected, setting duration to 1 minute" -ForegroundColor Yellow
        }
        
        Write-Host "  Detected duration: $durationInMinutes minutes" -ForegroundColor Gray
        
        # Format duration as XXXmin
        $formattedDuration = "${durationInMinutes}min"
        if ($durationInMs -eq 0) {
            $formattedDuration = "0min"  # Default if duration couldn't be determined
        }
        # Convert codec names to common naming convention
        $codecName = switch ($codec) {
            "HEVC" { "x265" }
            "AVC"  { "x264" }
            default { $codec.ToLower() }
        }
        
        # Determine resolution suffix
        $resolution = if ($height -ge 2160) { "2160p" }
                     elseif ($height -ge 1080) { "1080p" }
                     elseif ($height -ge 720) { "720p" }
                     elseif ($height -ge 480) { "480p" }
                     else { "${height}p" }
        
        # Remove special characters and replace spaces, dashes, and underscores with periods
        # First clean the original filename (remove special chars, replace spaces/dashes/underscores with periods)
        $newBaseName = $file.BaseName -replace '[^\w\s\-_]', '' -replace '[\s\-_]+', '.' -replace '\.+', '.'
        
        # Create the dimensions string
        $dimensionsStr = "${width}x${height}"
        
        # Then create the new filename with all information
        # Then create the new filename with all information
        $newName = "{0}.{1}.{2}.{3}.{4}.{5}{6}" -f $newBaseName, $codecName, $resolution, $dimensionsStr, $aspectRatio, $formattedDuration, $file.Extension
        # Perform renaming
        try {
            Write-Host "  Renaming to: $newName" -ForegroundColor Green
            $newPath = Join-Path -Path $file.DirectoryName -ChildPath $newName
            Rename-Item -Path $file.FullName -NewName $newName -ErrorAction Stop
        }
        catch {
            Write-Host "  Error renaming file: $_" -ForegroundColor Red
        }
    }
    
    Write-Host "`nRenaming complete!" -ForegroundColor Green
}
catch {
    Write-Host "Error: $_" -ForegroundColor Red
    exit 1
}

